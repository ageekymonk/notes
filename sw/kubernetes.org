* Kubernetes
** What is it
   - Orchestration tool for managing containers across hosts
   - Declarative not procedural
   - Auto scales and self healing
** Features
   - Scheduling
   - Lifecycle health
   - Auto scaling
   - Naming and discovery
     Built in DNS service
   - Load Balancing
   - Storage Volumes
   - Logging and monitoring
   - Debugging and introspection
   - Identity and authorization
     RBAC
   - Cluster Federation
     + For cluster in different region and different service providers
     + Active Passive Failure for cluster across service providers
   - Scheduled Jobs
   - Helm Package Manager
   - Stateful Sets
   - Alpha Clusters
** Components
   1. K8s Master
      1. kube-apiserver
         - Exposes REST API
         - Front end to the control plane
         - Consumes JSON (via manifest files)
      2. Cluster Store
         - Persistent Storage
         - Stores Cluster State and config
         - uses etcd
         - Source of truth of the cluster
      3. kube-controller-manager
         - Controller of Controllers
           - Node controller
           - Endpoint controller
           - Namespace controller
      4. kube-scheduler
         - Watches apiserver for new pods
         - Assigns work to nodes
   2. Nodes
      1. kubelet
         - kubernetes agent
         - registers node with cluster
         - watches apiserver
         - instantiates pods
         - exposes endpoint on :10255. /healthz, /spec, /pods
      2. Container Engine
         - Pluggable, can use rkt or docker
      3. kube-proxy
         - kubernetes networking
         - Loadbalances all pods behind a service
   3. API Server
   4. kubelet
      It is an agent on every node
   5. kubeproxy
      Sends request to right kube regardless of which ever node receives
   6. Pods
      - Fundamental Unit of deployment in kubernetes
   7. Services
      - only send to healthy pods
      - can be configured for session affinity
      - can point to things outside cluster
      - Random Loadbalancing
      - TCP/UDP
   8. Deployments
   9. Replication Sets
   10. Replication Controller
   11. Node Pools
       - Non homogenous machines grouped together
       - Even can have different versions of k8s
       -
** Terminology
   - Declarative Model & Desired State
     - Manifest file (yaml or json) specifies desired state
   - Pods
   -
* Minikube
** Start Minikube
  #+BEGIN_SRC
  minikube start --bootstrapper=localkube
  #+END_SRC
** Install Ingress
   #+BEGIN_SRC 
   minikube addons enable ingress
   #+END_SRC
* GCP
  - Everything in google is in containers. Even the VM.
  - Borg: Internal Container Scheduler. It was followed by Omega. Finally kubernetes
  - Application Ops
  - Cluster Ops
  - Configuration Change: causes most unplanned outage
  - Google Container Engine
    + Managed kubernetes
    + Runs stable k8s
    + Runs on Container optimized OS, which is security hardened and has in place upgrades and downgrades
    + Federated Ingress using Google Global Loadbalancer
  - Google Compute Engine
    + Faster Boot times. (~30s)
    + Per minute Billing
    + premptible VMs
    + Multi region usage without poking holes (like VPC Peering)
  - Google Container Registry
    + Secure
    + Private Docker Image
    + CI/CD Integration with Jenkins, Spinnaker, ...
  - Google Cloud Machine Learning is powered by Container Engine
  - Pokemon go is powered by container engine
  -
* EKS
  - EKS Network Plugin
    - Each pod is going to get AWS IP Routable Address
    - Secondary ENI ??
    -
* To Research
  - Prometheus
  - sysdig
  - datadog
  - stackdriver
  - App Armour

* Commands
** To get the kube dns ip
   #+BEGIN_SRC bash
   kubectl get svc --namespace=kube-system
   #+END_SRC
* Links
  [[https://stevesloka.com/2017/05/19/access-minikube-services-from-host/][Access Minikube services from Host on OSX]]
* API 
** Notes
   - client-go
   - Run inside the Cluster or Outside the cluster
   - clientcmd uses rest client underneath

** Examples
*** Print all Pods using clientcmd
   #+BEGIN_SRC go
package main

import (
	"flag"

	"github.com/golang/glog"
	"k8s.io/client-go/kubernetes"
	"path/filepath"
	"os"
	"k8s.io/client-go/tools/clientcmd"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
)

// optional - local kubeconfig for testing
var kubeconfig = filepath.Join(os.Getenv("HOME"), ".kube", "config")

func main() {

	// send logs to stderr so we can use 'kubectl logs'
	flag.Set("logtostderr", "true")
	flag.Set("v", "3")
	flag.Parse()

	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		glog.Errorf("Failed to load client config: %v", err)
		return
	}

	// build the Kubernetes client
	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		glog.Errorf("Failed to create kubernetes client: %v", err)
		return
	}

	// list pods
	pods, err := client.CoreV1().Pods("").List(metav1.ListOptions{})
	if err != nil {
		glog.Errorf("Failed to retrieve pods: %v", err)
		return
	}

	for _, p := range pods.Items {
		glog.V(3).Infof("Found pods: %s/%s", p.Namespace, p.Name)
	}


}

   #+END_SRC
*** Print all pods using rest client
    #+BEGIN_SRC go
package main

import (
	"flag"

	"github.com/golang/glog"
	"k8s.io/client-go/kubernetes"
	"path/filepath"
	"os"
	"k8s.io/client-go/tools/clientcmd"
	rest "k8s.io/client-go/rest"
	"k8s.io/client-go/kubernetes/scheme"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime/serializer"
)

// optional - local kubeconfig for testing
var kubeconfig = filepath.Join(os.Getenv("HOME"), ".kube", "config")

func main() {
	// send logs to stderr so we can use 'kubectl logs'
	flag.Set("logtostderr", "true")
	flag.Set("v", "3")
	flag.Parse()

	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		glog.Errorf("Failed to load client config: %v", err)
		return
	}

	gv := corev1.SchemeGroupVersion
	config.GroupVersion = &gv
	config.APIPath = "/api"
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}

	if config.UserAgent == "" {
		config.UserAgent = rest.DefaultKubernetesUserAgent()
	}

	restClient, err := rest.RESTClientFor(config)
	if err != nil {
		glog.Errorf("Err %v", err)
		return
	}

	result := &corev1.PodList{}

	restClient.Get().Namespace("").Resource("pods").Do().Into(result)

	for _, p := range result.Items {
		glog.V(3).Infof("Found pods: %s/%s", p.Namespace, p.Name)
	}
}
    
    #+END_SRC
*** Print all pods using dynamic pkg
    #+BEGIN_SRC go
package main

import (
	"flag"

	"github.com/golang/glog"
	"k8s.io/client-go/kubernetes"
	"path/filepath"
	"os"
	"k8s.io/client-go/tools/clientcmd"
	rest "k8s.io/client-go/rest"
	"k8s.io/client-go/kubernetes/scheme"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/client-go/dynamic"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// optional - local kubeconfig for testing
var kubeconfig = filepath.Join(os.Getenv("HOME"), ".kube", "config")

func main() {
	// send logs to stderr so we can use 'kubectl logs'
	flag.Set("logtostderr", "true")
	flag.Set("v", "3")
	flag.Parse()

	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		glog.Errorf("Failed to load client config: %v", err)
		return
	}

	gv := corev1.SchemeGroupVersion
	config.GroupVersion = &gv
	config.APIPath = "/api"
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}

	if config.UserAgent == "" {
		config.UserAgent = rest.DefaultKubernetesUserAgent()
	}

	client, err := dynamic.NewForConfig(config)
	if err != nil {
		glog.Errorf("Err %v", err)
		return
	}

	got, err := client.Resource(schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}).List(metav1.ListOptions{})
	if err != nil {
		glog.Errorf("Err %v", err)
		return
	}

	for _, item := range(got.Items) {
		glog.Infof("%s/%s", item.GetNamespace(),item.GetName())
	}


} 
    #+END_SRC